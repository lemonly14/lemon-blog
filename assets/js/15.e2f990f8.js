(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{212:function(t,r,e){"use strict";e.r(r);var s=e(2),a=Object(s.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"返回信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#返回信息","aria-hidden":"true"}},[t._v("#")]),t._v(" 返回信息")]),t._v(" "),e("p",[t._v("程序与捕获到的 "),e("strong",[t._v("error")]),t._v(" 不应该直接返回到客户端里去，因为 "),e("strong",[t._v("error")]),t._v(" 的信息量是非常大的。除了常见的错误名称，错误信息还包含了堆栈调用的信息。这些复杂的信息不应该直接返回到前端去，所以我们要对 "),e("strong",[t._v("error")]),t._v(" 进行简化过滤，返回给前端是清晰明了的信息。")]),t._v(" "),e("p",[t._v("那我们应该返回给前端那些信息呢？")]),t._v(" "),e("ul",[e("li",[t._v("http status code 2** 4** 5** "),e("a",{attrs:{href:"https://koa.bootcss.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 状态码"),e("OutboundLink")],1),t._v("\nkoa 的文档中有常见的 http 状态码说明，不在赘述。")]),t._v(" "),e("li",[t._v("message 其中包含错误信息")]),t._v(" "),e("li",[t._v("error_code 类似 http status code 开发者自己定义的 不过更加的详细")]),t._v(" "),e("li",[t._v("require_url 表示当前请求的 url")])]),t._v(" "),e("h2",{attrs:{id:"错误分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误分类","aria-hidden":"true"}},[t._v("#")]),t._v(" 错误分类")]),t._v(" "),e("p",[t._v("已知错误：比如说，前端传来一个参数 我们服务端要求 "),e("strong",[t._v("int")]),t._v(" 整型，前端却传过来一个字符串。我们在校验层校验出了这个错误。这就是一个已知错误，我们捕获到已知错误就可以明确的告诉前端错误信息。")]),t._v(" "),e("p",[t._v("未知错误：程序潜在的错误，这种错误是无意识的，我们根本不知道出错了。比如说，我们后期要连接数据库 输入账号密码 不小心输错了，这是未知错误。未知错误无法明确的告诉前端错误信息，但是我们有全局异常处理机制，它会帮助我们捕获到这个错误。")])])},[],!1,null,null,null);r.default=a.exports}}]);